\documentclass[12pt]{article}

\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage[hidelinks]{hyperref}
\usepackage{mathbbol,bm,amsmath,amsthm,amsfonts,amssymb}
\usepackage{mathtools}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage[mathscr]{euscript}
\usepackage[margin=0.5in]{geometry}
% \usepackage[shortlabels]{enumitem}
\usepackage{tikz}


% \setlist[itemize]{label={$\bullet$}, topset=0.2ex, partopset=0pt, parsep=4pt, itemsep=0pt, leftmargin=4.5mm, labelsep=0.5ex}
% \setlist[enumerate]{align=left, listparindent=0pt}

\newcommand{\PP}{\mathscr{P}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\renewcommand{\iff}{\;\leftrightarrow\;}
\newcommand{\floor}[1][x]{\lfloor #1\rfloor}
\newcommand{\ceil}[1][x]{\lceil #1\rceil}
\newcommand{\mat}[1][A]{\text{\textbf{#1}}}
\newcommand{\I}{\mathbb{1}}

\renewcommand{\thesubsection}{\arabic{subsection}}
\renewcommand{\thesubsubsection}{\alph{subsubsection}}

\title{\huge Exam preparation cheetzheet: \\ \textit{Stuff from}}

\author{\LARGE MNF130V2020}

\begin{document}

\maketitle

\bigskip

\newpage

\subsection{Chapter 1}
\smallskip
\textbf{Propositional logic}:. Logical $\wedge,\vee,\oplus$ are trivial. \\
\smallskip
\textbf{Conditional statements (implication)}: $p \rightarrow q$, if $p$ then $q \equiv p $ only if $q \equiv$ $p$ is a sufficient condition for $q$. \\
In other words, q is a necessary condition for p. $p \rightarrow q$ is false then $p$ is true and $q$ is false and otherwise true. \\
$\neg(p\rightarrow q)\equiv p \wedge (\neg q)$, $p \rightarrow q$ is equivalent to its contrapositive $\neg q \rightarrow \neg p$, but \textbf{not} to its \textbf{converse} $q \rightarrow p$ \textbf{or} its inverse $\neg p \rightarrow \neg q$. \\
\smallskip
\textbf{Biconditional statements:} $ p \iff q$ or expanded to $(p \rightarrow q) \wedge (q \rightarrow p)$. \\
\smallskip
\textbf{De Morgan:} $\neg(p \vee q) \equiv (\neg p) \wedge (\neg q)\ ;\ \neg(p \wedge q) \equiv (\neg p ) \vee (\neg q) $
\smallskip
Propositional logic can be represented by gates, creating combinational circuits which can represent \textbf{any} logical expression. \\
\medskip
\textbf{Quantifiers:} \\
$
\forall x(P(x) \rightarrow Q(x)) \equiv
$
\textit{for all x, if P(x) then Q(x)} \\
$
\exists x(P(x) \wedge Q(x)) \equiv
$
\textit{there exists an x such that P(x) and Q(x)} \\

\textit{P(x),Q(x)} are propositional functions and there is always a \textbf{domain} or \textbf{universe of discourse}, either implicit or explicitly stated,over which the variable ranges. \\
\medskip
\textbf{Negations of quantified propositions:} $\neg \forall xP(x)\equiv \exists x\neg P(x); \neg \exists P(x) \equiv \forall x \neg P(x)$. \\
\medskip
\textbf{Theorem:} A proposition that can be proved; \textbf{lemma:} a simple theorem, commonly used as part of a greater picture to prove other theorems; \textbf{proof:} A demonstration that a proposition is true, \textbf{collorary:} A proposition that can be proved as a consequence of a theorem that has just been proved. A collorary can be seen as ``Side effects`` of the prooved theorem. \\
\medskip
A \textbf{valid} argument is an argument using correct rules of inference based on tautologies (something that will always give the \textbf{true} conclusion in \textbf{any} given scenario. I. E. a tautology is something that is always true for all possible combinations.) \\
An \textbf{invalid} argument can be referred to as a \textbf{fallacy}, such as affirming the conclusion, denying the hypothesis, begging the question or circular reasoning. They can lead to false conclusions. \\
\medskip
\textbf{Some rules of inference:} 
\begin{itemize}
\item $[ p \wedge (p \rightarrow q) ]$ Modus Ponens
\item $[ \neg q \wedge (p \rightarrow q)]$ Modus Tollens
\item $[(p \rightarrow q) \wedge (q \rightarrow r)] \rightarrow (p \rightarrow r)$ Hypothetical syllogism (Transitivity)
\item $[(p \vee q) \wedge (\neg p)] \rightarrow q$ Disjunctive syllogism
\item $\{P(a) \wedge \forall x [P(x) \rightarrow Q(x)]\} \rightarrow Q(a)$ Universal modus ponens
\item $\{\neg Q(a) \wedge \forall x[P(x) \rightarrow Q(x)]\} \rightarrow \neg P(a)$ Universal modus tollens
\item $(\forall x P(x)) \rightarrow P(c)$ Universal instantiation
\item $(P(c) arbitrary\ c) \rightarrow \forall xP(x)$ Universal generalization
\item $(\exists xP(x)) \rightarrow (P(c)\ for\ some\ c)$ Existential instantiation
\item $(P(c)\ for\ some\ element\ c) \rightarrow \exists x P(x)$ Existential generalization.
\end{itemize}
\newpage
\subsubsection{Proofs} 
\bigskip
\textbf{Trivial proof:} A proof that $p \rightarrow q$ just shows that $q$ is true witout using the hypothesis $p$. \\
\textbf{Vacuous proof:} A proof of $p \rightarrow q$ that just shows that the hypothesis $p$ is false. \\
\textbf{Direct proof:} A proof of $p \rightarrow q$ that shows that the assumption of the hypothesis $p$ implies the conclusion of $q$. \\
\textbf{Proof by contraposition:} A proof of $p \rightarrow q$ that shows that the assumption of the negation of the conclusion $q$ implies the negation of the hypothesis $p$ (in other words, proof of contrapositive).\\
\textbf{Proof by contradiction:} A proof of $p$ that shows that the assumption of the negation of $p$ leads to a contradiction. \\
\textbf{Proof by cases:} A proof of $(p_1 \vee p_2 \vee p_3 ... p_n) \rightarrow q$ that shows that each conditional statement $p_i \rightarrow q$ is true. Statements of the form $p \iff q$ require that both $p \rightarrow q$ and $q \rightarrow p$ be proved. It is sometimes necessary to give the two separate proof (usually a direct proof or a proof by contraposition); other times a string of equivalences can be constructed starting with $p$ and ending with $q : p \iff p_1 \iff p_2 ... \iff p_n \iff q$. \\
To give a \textbf{constructive proof} of $\exists x P(x)$ is to show how to find an element $x$ that makes $P(x)$ true. \textbf{Non-constructive existence proofs} are also possible, often using \textbf{proof by contradiction}. \\
One can \textbf{disprove} a universally quantified proposition $\forall x P(x)$ simply by giving a \textbf{counter example}, i.e. an object $x$ such that $P(x)$ is \textbf{false}. One can, however, not proove it with such an example. \\
\medskip
\textbf{Fermat's last theorem:} There are no positive integer solutions of $x^n + y^n = z^n\ if\ n > 2$. \\
An integer is \textbf{even} if it can be written as $2k$ for some integer $k$; an integer is \textbf{odd} if it can be written as $2k + 1$ for some integer $k$. Every number is even or odd but not both. A number is \textbf{rational}, if it can be written as $p/q$ with $p$ being an integer and $q$ strictly a non-zero integer. \\
\newpage
\subsection{Chapter 2}
\subsubsection{Sets}
\textbf{Empty set:} A set with no elements, commonly denoted as $\emptyset$. Do not confuse this with the set only containing the empty set. The difference is that the empty itself is empty, whereas the set containing the empty set has a single element. \\
\textbf{Subset:} $A \subseteq B \equiv \forall x(x \in A \rightarrow x \in B)$, whereas a proper subset is $ A \subset B \equiv (A \subseteq B) \wedge (A \neq B)$, in other words, $B$ has at least one element different from the set $A$. \\
\textbf{Equality of sets:} $A = B \equiv (A \subseteq B \wedge B \subseteq A) \equiv \forall x(x \in A \leftrightarrow x \in B)$. \\
\textbf{Power set:} $\PP(A) = \{B | B \subseteq A \}$, the set of all subsets of $A$. A set with $n$ elements has $2^n$ subsets. \\
\textbf{Cardinality:} $|S|$, the number of elements in $S$. \\
Some specific sets in regards to cardinality: $\R$ is the set of real numbers, represented by either finite or infinite decimals; \\
$\N$ is the set of all natural numbers (eg. $\{0,1,2,3,4,5...\}$), $\Z$ is the set of integers $\{... -2, -1, 0, 1, 2, ...\}$ and can also be denoted with only the positive or negative subset. $\mathbb{Q}$ is the set of rational numbers, where $\{ p / q | p, q \in \Z \wedge q \neq 0 \}$, $\mathbb{Q}^+$ is the set of positive rational numbers and a subset of $\mathbb{Q}$. \\
\textbf{Set operations:} $A \times B = \{ (a,b) | a \in A \wedge b \in B\}$ (\textbf{Cartesian Product}); $\overline{A}$ is the set of elements in the universe which are \textbf{not} in $A$ (\textbf{complement}); $A \cap B = \{ x | x \in A \wedge x \in B\}$ (\textbf{intersection}); $A \cup B = \{ x | x \in A \vee x \in B\}$ (\textbf{union}); \\
$A - B = A \cap \overline{B}$ (\textbf{difference}); $A \oplus B = (A - B) \cup (B - A)$, (\textbf{symmetric difference/xor}) \\
\textbf{Inclusion-exclusion (simple case):} $|A \cup B| = |A| + |B| - |A \cap B|$\\
\textbf{De Morgan's laws for sets:} $\overline{A \cap B} = \overline{A} \cup \overline{B}$; $\overline{A \cup B} = \overline{A} \cap \overline{B}$ \\
A \textbf{function} f from $A$ (\textbf{the domain}) to $B$ (\textbf{the co-domain}) is an assignment of a unique element of $B$ to each element of $A$. Write $f: A \rightarrow B$. Write $f(a) = b$ if $b$ is assigned to $a$. \textbf{Range} of $f$ is $\{ f(a) | a \in A\}$; $f$ is \textbf{onto/surjective} $\equiv$ range $(f)$ = $B$; $f$ is \textbf{one-to-one/injective} $\equiv$ $\forall a_1 \forall a_2 [f(a_1) = f(a_2) \rightarrow a_1 = a_2]$ \\
If $f$ is one-to-one \textbf{and} onto, it is \textbf{bijective} and the \textbf{inverse} function $f^{-1} : B \rightarrow A$ is defined by $f^{-1}(y) = x \equiv f(x) = y$. \\
If $f : B \rightarrow C$ and $g : A \rightarrow B$, then the \textbf{composition} $f \circ g$ is the function from $A$ to $C$ defined by $f \circ g(x) = f(g(x))$. \\
\textbf{Rounding functions:} $\floor{}$ is the largest integer less than or equal to x \textbf{floor function}; $\ceil{}$ is the smallest integer greater than or equal to $x$ \textbf{the ceiling function}. \\
\textbf{Summation notation:}

$$
\sum_{n=1}^{n} a_i = a_1 + a_2 + a_3 + ... + a_n
$$
\textbf{Sum of first $n$ positive integers:} 
$$
\sum_{j=1}^{n} j = 1 + 2 + ... + n = \frac{n(n +1)}{2}
$$
\textbf{Sum of squares of first $n$ positive integers:}
$$
\sum_{j=1}^{n} j^2 = 1^2 + 2^2 + ... + n^2 = \frac{n(n +1)(2n+1)}{6}
$$
\textbf{Sum of geometric progression:}
\textbf{(I don't think we did this in the course)}\\ 
\newpage
Two sets are said to have the \textbf{same cardinality} if there is a \textbf{bijection} between them. We can say that $|A| \leq |B|$ if there is a one-to-one function from $A$ to $B$. \\
A set is $countable$ if it is finite or there is a \textbf{bijection} from the positive integers to the set. \textbf{In other words}, if the elements of the set can be listed (e.g. $a_1, a_2, ...$). Sets of the latter type are called $countably infinite$ and the \textbf{cardinality of these sets are denoted with $\aleph_0$ }. The empty set, the integers and the rational numbers \textbf{are countable}. The union of a countable number of countable sets is countable. \\
\textbf{Schroder-Bernstein theorem:} If $|A| \leq |B|$ and $|B| \leq |A|$ then it must be that $|A| = |B|$. This can be explained as if there is a one-to-one function from A to B and a one-to-one function from B to A, then there is a one-to-one and onto function from A to B. \\
\textbf{Matrix Multiplication:} The $(i,j)^{th}$ entry of \textbf{AB} is $\sum_{t=1}^k a_{it}b_{tj}$ for $1 \leq i \leq m$ and $1 \leq j \leq n$, where \textbf{A} is an $m \times k$ matrix and \textbf{B} is a $k \times n$ matrix. \\
\textbf{Identity matrix $I_n$} with 1's on the main diagonal and 0's elsewhere is the multiplicative identity. \\
Cardinality arguments can be used to show that some functions are \textbf{uncomputable}. \\
Matrix addition (+), Boolean meet ($\wedge$) and join ($\vee$) are done entry-wise; Boolean matrix product ($\odot$) is like matrix multiplication using boolean operators. \\
\textbf{Transpose:} \textbf{A}$^t$ is the matrix whose $(i,j)^{th}$ entry is $a_{ij}$ (the $(j,i)^{th}$ entry of \textbf{A}); \\
\textbf{A} is \textbf{symmetric} if \textbf{$A^t=A$};
\newpage
\subsection{Chapter 3}
\textbf{Algorithm} are commonly expressed in \textbf{pseudo-code} when not directly implemented in a domain specific area. \\
\textbf{Keywords for algorithms:} \{input, output, definiteness, correctness, finiteness, effectiveness, generality\}. \\
\textbf{Greedy algorithms:} Will examine and pick the best choice at a given step. Not always the best. \\
\textbf{Brute forcing:} Specifically in discrete mathematics, this referres to examining the entire space of solutions and then determine the best one (very inefficient, sometimes necessary). Not explained in this course: \textbf{dynamic programming, probabilistic algorithms, divide-and-conquer}. \\
\textbf{Halting problem:} The unsolvable computing problem whether a program will halt given input. (Alan Turing for reference...) \\
\textbf{Big-O:} Half of inf102 is just this: \\
$f(x) = O(g(x))$ means $\exists C\exists k \forall x(x > k \rightarrow |f(x)| \leq C|g(x)|)$. Big-O of a sum is the largest (fastest growing) of the functions in the sum. Big-O of a product is the product of the big-O's of the factors. If $f$ is $O(g)$, the $g$ is $\Omega (f)$ "big-omega". If $f$ is both big-O and big-Omega of $g$, then $f$ is $\theta (g)$ "big-theta". \\
\textbf{Little-O:} We say that $f(x)$ is $o(g(x))$ if $\lim_{x\rightarrow \infty}f(x)/g(x) =0$.\\
\textbf{Powers grow faster than logs:} $(\log n)^c$ is $O(x^d)$ but not the other way around, where $c$ and $d$ are positive numbers. \\
If $f_1(x)$ is $O(g_1 (x))$ and $f_2(x)$ is $O(g_2(x))$, then $(f_1+f_2)(x)$ is $O(\max (g_1(x),g_2(x)))$ and $(f_1f_2)(x)$ is $O(g_1(x)g_2(x))$. \\
$\log n!$ is $O(n \log n)$. \\
\textbf{Time complexity:} Binary search = $O(\log n)$ (cut half of possibilites at each step), linear search $O(n)$ (all input is examined exactly once), both have \textbf{space complexity (in terms of computer memory) O(1)} without taking the input into account. Bubble sort and insertion sort have $O(n^2)$. \\
Matrix multiplication has standard algorithm time complexity of $O(m_1m_2m_3)$ if the matrices have dimensions $m_1 \times m_2$ and $m_2 \times m_3$. \\
Efficient algorithms can reduce the complexity of multiplying two $n \times x$ matrices from $O(n^3)$ to $O(n^{\sqrt{7}})$
Important complexity classes include polynomials $n^b$, exponential ($b^n$ for $b > 1$) and factorial ($n!$). \\
A problem that can be solved by an algorithm with polynomial worst-case time complexity is called \textbf{tractable}; otherwise \textbf{intractable}. \\
\textbf{P=NP problem:} The class \textbf{P} is the class of tractable problems. The class \textbf{NP} consists of the problems for which it is possible to check solutions (\textbf{not FIND solutions}) in polynomial time. This means that \textbf{$P \subseteq NP$} yet the \textbf{P=NP} problem is unsolved because it has not been shown whether \textbf{P=NP}.





 
\end{document}